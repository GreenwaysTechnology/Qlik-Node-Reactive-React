					MicroServices
..............................................................................................

What is Micro Service?

MicroService is collection of architecture principles for building distributed applications.

Distributed Application:

Biz Models

-Data 
   -Store    - Data Layer
   -Process   - Service
   -Presentation -UI layer

History of Distributed Computing:

1.IBM MainFrame
    
 Thin client-------|IBM MainFrame---Process + DataStorage

2.Client-Server - Based Micro Computers
  
  Single Tier client server

 PersonalComputer-------|MicroComputer---Process + DataStorage

 Two Tier client server  -RPC 

 PersonalComputer-------|MicroComputer---Process + DataStorage
 (UI + BIZ Logic)-------MicroComputer-----DataStorage


 Three Tier client server  

  PersonalComputer-------|MicroComputer---Process + DataStorage

 (UI + client side biz logic)-------MicroComputer--server side biz logic---DataStorage

 N-Tier client server  

  PersonalComputer-------|MicroComputer---Process + DataStorage

 (UI + client side biz logic)---------[server side biz logic-m1]--network---[DataStorage-m2]

After 1990s

N-Tier client server - web based

  UI(Browser)------internet----http-------|WebServer----|WebContainers---Run a program--database.
...........................................................................................
			 N-Tier client server -Java - JEE
...........................................................................................

Technology Components of N-Tier client server Architecture in java:
.........................................................

1. Web container - JVM - Where we are running web compoents
     -Web Tech - Servlets/JSP
2. JDBC - connector to connect databases

How application was built and delivered to the customer?

-SDLC - Water fall

-Req
-Design
-development
-testing
-deployment-Production 
  ----Live
   
Monolith:

-Technology first J2EE, Domain Next.

Problems in Traditonal destributed app development:

-Vendor-lock in : Mono-lithic
   -DEV,TESTING,PRODUCTION.
-Work flow is highly sequencial
   Req -Complete
   Dev
   testing
   Release
   Production
  Delay in delivery:Cost increased
-Production cost was huge

Data Centers
 -need to purchase high powered servers - bare metal servers
 
Cost:
   -Hardware
   -OS -Linux-Ubuntu
   -Tools -Servers,databases etc....
   -Matrix Hell -  Mapping software components in dev and Production..
............................................................................................					Amzon and distributed Computing
............................................................................................

How to simplify the Software work flow?

Automation: Devops
  Testing
  Release
  Production

Different Tech Stack:
 -Break the Application into smaller and smaller application

Build ,test,release ,deploy , maintain in smaller -  sub domains

IF App needs to talk to external systems like Message Brokers, other Systems like Main frames.

RPC/RPI
MOM
Connectors Arch.

BIZ LOGIC:

1- Service Layer : isloate service layer into separate component

 can be inside one app - one layer, that layer may run on different jvms -  distributed Arch.


Layer :

 Client ---- Web Layer  ----Service Layer ---- Repository Layer
...............................................................................................
/////////////////////////////////////////////////////////////////////////////////////////////

Packaging Model:
 
WAR - Web archive
EAR .

Problems with Single JAR/WAR:

1. Scalability
 Vertical scablitity
 Horzitional scability 

2.Deployments
    -Bare Metal Deployment

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
Monoloith distributed app development drabackbacks:

-Time is taken for project delivery
   -Requirements 
   -High level design and low level design
   -coding
   -testing
   -release
   -production- live

-Technology Stack and Vendor lock in
   -You need to build the entire app using one technology or one vendor product
    eg: J2EE, Oracle,Weblogic

-Production and maintance cost
  -You need to setup large data centers , you need to maintain them.

Companies like amzon,netflix,google wanted to change the app development model.
                                "Micro services"


Micro services are architural model of req,dev,test,relase,production,maintaince different ways.
    Continous req collecting
    Continous dev
    Continuous testing
    Continuous release
    Continuous deployment
    Using rented data centers: Cloud

-Domain First, Technology Next: Domain Driven Design.
-No Vendor lock- Multi tech stack.
-Indidual dev , deployment - orders is development ,tested,deployed,customers are developed,tested deployment.
   -Parrel dev.
-Automation -dev ops
   release - CI 
   deployment - Containerized - Docker..
-Introduction of Cloud computing
...............................................................................................		..............................................................................................

                                  Micro Services Design Pattern
..............................................................................................

Implementation Patterns:
........................

1.DOMAIN Models
  Decompose by biz features
  Decompose by sub domains

..............................................................................................					Micros services Development - pattern
..............................................................................................

1.Select Language and Frameworks
   Javascript 

JavaScript Features
 -Services are exposed as "Objects"

Domain - OrderManagement

-OrderMaster
-OrderDetail

Objects
  -state
  -behvaiour - methods -biz operation
..............................................................................................						Service Design

Services are Objects.
....................

Services are exposed as Object in diffent style.How to access those objects outside and inside system.

Services are exposed as "APIS"

API Design Styles:

1.WebServices
   -SOAP Based -SOA
   -REST API
   -GRAPHQL API
2.RPC
.............................................................................................
				Service Communications
 
   Two Domains are going to collbrate each other to carry a biz transaction.


In Micro Services


FiberOpticService
     is 
   Running 
     inside
 One Application
       |
     Runtime
       |
  VM -Container

      OS
 
     |
     |   data
     |

Billing is Running
     is 
   Running 
     Another
 One Application
      |
     Runtime
       |
  VM -Container

      OS

Class ----will become  Objects

Object Communication === Service Communication



-SAME JVM(Runtime)
  Calling methods from one object(FiberDataService) to another object (BillingService).
-Different Runtime(JVM)
   -Networks - Protocals
    RestFull
      -HTTP 
   -RPC/RIP
	-ORB
        -RMI
        -gRpc
   -MOM - Message Brokers
        RabbitMQ
	Kaffka
	etc...
   -Event Bus
	-TCP

..............................................................................................					Service communication related Design Pattern
				   (Sevices Are Eagar or Lazy)
..............................................................................................

Types of Communication.

1.Async Communication 
    -MOM - RabbitMQ
    -Programm level async communication - threads,nonblocking ios
2.Sync Communication
.............................................................................................
			Service Failures - Realiability Pattern
.............................................................................................

1.UnAvailability

2.Timeout due to slow calls

How to handle failures , how to return proper response to caller?

Reliability Design patterns :fault tolerance 

 -Circuit Breaker
 -Bulk Head
 -Rate Limiter
 -Retry
 -TimeLit
.............................................................................................
				Service Communications in network and its Problems:
..............................................................................................

Service Communications in network and its Problems:
...................................................

Services are going to talk each other.

If they want to talk, What services should know each other?

 -Location
     ip address

In monolithic(traditional) deployment - ip address , ports are well known (hardcoded)
but in containers/ cloud env which are highly dynamic.

Where Micro services typically runs in a virtualized or containerized envs , locations are highly dynamic.

Services need to be registered some where and others services will ask registered location, that , hey give me that service

Service Registry and Discovery Pattern:
.......................................
Service Registry:
  -database - stores service informations

Service Discovery:
  locating services from the service registry

Types of Service discovery:
 -Client Side Service Discovery
 -Server Side Service Discovery
.............................................................................................
.............................................................................................
			DataSource - /Database Design in Micro services
..............................................................................................
Data Management :

 A Service need to store data in data sources - Database
  
Database Per Service.

 FiberOpticService
Each service has its own schema. 
you can have more than one tables per service

Database: 
  Collection of tables,views,other objects

Shared Database:
  Sharing db for more than one services .

Service Communication and Data Management

How to implement Transactions In Microservices?

It is very very difficult to implement and track transactions across multiple services.

Transactional Designpattern:

1.2PC  - 2 Phase Commit

2.Saga
    -EDA - Event Driven Architectures
  Saga Implementation
	-Choreography
        -Orchestration

..............................................................................................
				Deployment
..............................................................................................

Deployment patterns

Multiple service instances per host
Service instance per host
Service instance per VM
Service instance per Container
Serverless deployment
Service deployment platform
............................................................................................
			Management Patterns
...........................................................................................


2.Application Metrics
     To monitor Application behaviours

Tools:
   Prometheus
   AWS Cloud Watch

3.Auditing
    User auditing,application auditing - Performance
    Record User activties in a databse

4.Distributed Tracing /Tracking
   If i want to track service calls
    A -->B ---C -- Something
   You can Track Exception Hierachies
  
 Open zipkin
 Open Tracing

5.Health Check Api
    To test health of apis,infra components.

 Some implemetations provides health endpoints where you can get helath metrics information
that can be feed to tools 

-Prometheus
.............................................................................................
////////////////////////////////////////////////////////////////////////////////////////////
				Micro Services - Implementations
............................................................................................

Microservices is langugage,platform,os independant. 

Java:
 -Spring Cloud
 -Quarkus
 -Light4J
 -Vertx
 etc...

Javascript : nodejs

-  Moleculer
-  Seneca
-  Loop back
..............................................................................................

        Moleculer

Progressive microservices framework for Node.js

Moleculer is framework which has implemented most of common microservices design patterns.

Moleculer features:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
7.plugin/middleware system
8.support versioned services
9.support Streams
10.service mixins
11.built-in caching solution (Memory, MemoryLRU, Redis)
12.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
13.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
14.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
15.pluggable parameter validator
16.multiple services on a node/server
17.master-less architecture, all nodes are equal
18.parameter validation with fastest-validator
19.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
20.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
21.official API gateway, Database access and many other modules…
.............................................................................................
				Moleculer Architecture and Core concepts
.............................................................................................

1.Service:
  A Service is a simple java script module containing some part of a complex application.
  eg: UserService - contains information about users -  findAll users,save user,findBy,delete,update.
 It is isloated and self contained from the whole application, every service independant, meaning that even if the service goes offline or crashes the remaining services would be unaffected.

2.Node
   A node is simple os process(noderuntime). node may run local machine or external network.
   On a node one or more services are running.

3.Service Broker
   Service Broker is heart of moleculer.
   Service Broker is runtime for moleculer apps.
   Service Broker provides all infrastructure components - like    servicediscovery,loadbalancer,network transporters,message bus .... 

4.Transporter
   Transporter is communication bus that services are used to communicate across the network
   It can transfer message,events,request,response....

5.GateWay
    API Gateway exposes exposes moleculer services to end users.
   if external system/users who can communicate moleculer micro service apps via gate way only.
.............................................................................................
				Services:

1.HTTP services - REST API Style
   Services are exposed for outsideworld

2.Back end services - RPC API Style
   Services are used to encasulate biz logics like database operations,any biz


service names and file names:

math.service.js
hello.service.js

Create  Service Broker Object

const { ServiceBroker } = require('moleculer')

//ServiceBroker object creation
const broker = new ServiceBroker();

microserviceapp>node services/brokerinit.service.js
[2021-10-04T05:35:35.211Z] INFO  laptop-r2tggfdl-15380/BROKER: Moleculer v0.14.17 is starting...
[2021-10-04T05:35:35.213Z] INFO  laptop-r2tggfdl-15380/BROKER: Namespace: <not defined>
[2021-10-04T05:35:35.213Z] INFO  laptop-r2tggfdl-15380/BROKER: Node ID: laptop-r2tggfdl-15380
[2021-10-04T05:35:35.215Z] INFO  laptop-r2tggfdl-15380/REGISTRY: Strategy: RoundRobinStrategy
[2021-10-04T05:35:35.215Z] INFO  laptop-r2tggfdl-15380/REGISTRY: Discoverer: LocalDiscoverer
[2021-10-04T05:35:35.222Z] INFO  laptop-r2tggfdl-15380/BROKER: Serializer: JSONSerializer
[2021-10-04T05:35:35.233Z] INFO  laptop-r2tggfdl-15380/BROKER: Validator: FastestValidator
[2021-10-04T05:35:35.235Z] INFO  laptop-r2tggfdl-15380/BROKER: Registered 13 internal middleware(s).
[2021-10-04T05:35:35.250Z] INFO  laptop-r2tggfdl-15380/$NODE: Service '$node' stopped.
[2021-10-04T05:35:35.251Z] INFO  laptop-r2tggfdl-15380/BROKER: ServiceBroker is stopped. Good bye.
.........................................................................................
				Service Design - RPC

const { ServiceBroker } = require("moleculer");

//create Service Broker object 
const broker = new ServiceBroker();

//Create Service Object
//service schema - Object definition
broker.createService({
    name: 'hello',
    actions: {
        //apis
        sayHello() {
            return 'Hello,MicroService!!'
        }
    }
});

// function main() {
//     //start the broker and deploy the service
//     broker.start()
//         .then(() => {
//             console.log('services are ready to access')
//             //invoke service methods
//             broker.call('hello.sayHello')
//                 .then(res => console.log(res))
//                 .catch(err => console.log('service method gives error ', err));
//         })
//         .catch(err => {
//             console.log('deployment failed -->', err)
//         });
// }

//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        const response = await broker.call('hello.sayHello');
        console.log(response);
    }
    catch (err) {
        console.log(err);
    }

}


main();
.............................................................................................
				Single Service Multiple Methods
..............................................................................................
const { ServiceBroker } = require("moleculer");

//create Service Broker object 
const broker = new ServiceBroker();

//Create Service Object
//service schema - Object definition
broker.createService({
    name: 'greeter',
    actions: {
        //apis
        sayHello() {
            return 'Hello,MicroService!!'
        },
        sayHai() {
            return 'Hai,MicroService!!!';
        },
        sayWelcome() {
            return 'Welcome ,MicroService!'
        }
    }
});

//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        const hello = await broker.call('greeter.sayHello');
        const hai = await broker.call('greeter.sayHai')
        const greet = await broker.call('greeter.sayWelcome')
        console.log(hello);
        console.log(hai);
        console.log(greet);

    }
    catch (err) {
        console.log(err);
    }

}


main();
.............................................................................................
				  MultiService On single Broker
.............................................................................................

const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,MicroService!!'
        },
    }
});

broker.createService({
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai,MicroService!!'
        },
    }
});


broker.createService({
    name: 'welcome',
    actions: {
        sayWelcome() {
            return 'Welcome,MicroService!!'
        },
    }
});

//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        const hello = await broker.call('hello.sayHello');
        const hai = await broker.call('hai.sayHai')
        const greet = await broker.call('welcome.sayWelcome')
        console.log(hello);
        console.log(hai);
        console.log(greet);

    }
    catch (err) {
        console.log(err);
    }

}


main();
...............................................................................................					Versioning Services
http://mydomain/api/v1/someresource

http://mydomain/api/v2/someresource

const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    version: 1,
    actions: {
        sayHello() {
            return 'Hello,Legacy MicroService!!'
        },
    }
});


broker.createService({
    name: 'hello',
    version: 2,
    actions: {
        sayHello() {
            return 'Hello,Modern MicroService!!'
        },
    }
});

//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        const oldhello = await broker.call('v1.hello.sayHello');
        const newhello = await broker.call('v2.hello.sayHello');
        console.log(oldhello);
        console.log(newhello);

    }
    catch (err) {
        console.log(err);
    }

}

main();
..............................&&&&&&&&&&&&&&&&&&............................................
				Meta Data and actions -  actions types

actions:
  Are used to represent methods.

Methods can be represented in two ways:

Way -1:
actions : {
 
  sayHello(){
     return 'hello'
  }

}
Way-2: you can add meta information to a methods

meta informations will discuss later.

actions: {
  
  sayHello: {
    
       handler(){
          
          return 'Hello'
           
       } 
  }

} 

const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'greeter',
    version: 1,
    actions: {
        sayHello: {
            //handler:biz logic goes inside
            handler() {
                return 'Hello! Handler Microservice'
            }
        },
        sayHai: {
            handler() {
                return 'Hai! Handler Microservice!'
            }
        }
    }
});


async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        const hello = await broker.call('v1.greeter.sayHello');
        const hai = await broker.call('v1.greeter.sayHai');

        console.log(hello);

    }
    catch (err) {
        console.log(err);
    }

}

main();
*********************************************XXXXXXXXXX***************************************

Args and Parameters


Args: - Receiver:
................
const hello = await broker.call('hello.sayHello',{name:'Subramanian'})

-Parameters must be encapsulated inside object only - {name:'subramanian'}

-Args must be received via one Object called "Context" Object

Context :

-it is proxy object for broker meaning that, similar broker.
-Most of the broker features are availble inside context object
-Context objects are created by moleculer automatically.
-We can grab context object reference inside actions method args
-Using context 
   -read parameters - ctx.params
   -you can call other service methods -  service communication. ctx.call
   -if you want to access broker information 

const { ServiceBroker } = require("moleculer");

const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    actions: {
        sayHello(ctx) {
            // console.log(ctx.params.name);
            const { name,message } = ctx.params;
            return `${message} , ${name}`
        }
    }
});



//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        //pass parameters
        const response = await broker.call('hello.sayHello', { name: 'Subramanian',message:'Hello' });
        console.log(response);
    }
    catch (err) {
        console.log(err);
    }

}


main();
..........................................................................................
				 Params Validation
...........................................................................................

const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {

        add: {
            //metadata : Validatation code
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params;
                return a + b;
            }
        }
    }
});



//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        //pass parameters
        let response;
        response = await broker.call('math.add', { a: 10, b: 10 });
        console.log(response);
        response = await broker.call('math.add', { a: 10, b: 10 });
        console.log(response);
        response = await broker.call('math.add', { a: '10', b: 10 });
        console.log(response);
    }
    catch (err) {
        console.log(err);
    }

}


main();
.............................................................................................
				Async code - with Timer and Promise
.............................................................................................
const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {

        add: {
            //metadata : Validatation code
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params;
                //wrap the code inside timer and promise
                return new this.Promise((resolve, reject) => {
                    setTimeout(resolve, 5000, (a + b))
                })
            }
        }
    }
});



//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        //pass parameters
        let response;
        response = await broker.call('math.add', { a: 10, b: 10 });
        console.log(response);

    }
    catch (err) {
        console.log(err);
    }

}


main();
.............................................................................................
				Service Parameters Dynamically
...........................................................................................


REPL: READ Evaulate Print Loop:
- interactive command line tool, used for testing application.

node provides REPL
node

Moleculer provides REPL Prompt for testing services interactivly.

npm install moleculer-repl --save-dev

>node services/repl.service.js
[2021-07-24T09:34:52.394Z] INFO  laptop-r2tggfdl-6988/BROKER: Moleculer v0.14.16 is starting...
[2021-07-24T09:34:52.396Z] INFO  laptop-r2tggfdl-6988/BROKER: Namespace: <not defined>
[2021-07-24T09:34:52.397Z] INFO  laptop-r2tggfdl-6988/BROKER: Node ID: laptop-r2tggfdl-6988
[2021-07-24T09:34:52.398Z] INFO  laptop-r2tggfdl-6988/REGISTRY: Strategy: RoundRobinStrategy
[2021-07-24T09:34:52.399Z] INFO  laptop-r2tggfdl-6988/REGISTRY: Discoverer: LocalDiscoverer
[2021-07-24T09:34:52.407Z] INFO  laptop-r2tggfdl-6988/BROKER: Serializer: JSONSerializer
[2021-07-24T09:34:52.419Z] INFO  laptop-r2tggfdl-6988/BROKER: Validator: FastestValidator
[2021-07-24T09:34:52.421Z] INFO  laptop-r2tggfdl-6988/BROKER: Registered 13 internal middleware(s).
[2021-07-24T09:34:52.440Z] INFO  laptop-r2tggfdl-6988/REGISTRY: '$node' service is registered.
[2021-07-24T09:34:52.443Z] INFO  laptop-r2tggfdl-6988/REGISTRY: 'math' service is registered.
[2021-07-24T09:34:52.443Z] INFO  laptop-r2tggfdl-6988/$NODE: Service '$node' started.
[2021-07-24T09:34:52.444Z] INFO  laptop-r2tggfdl-6988/MATH: Service 'math' started.
[2021-07-24T09:34:52.445Z] INFO  laptop-r2tggfdl-6988/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 13ms.
mol $ help

  Commands:

    help [command...]                                          Provides help for a given command.
    q                                                          Exit application
    actions [options]                                          List of actions
    bench [options] <action> [jsonParams] [meta]               Benchmark a service
    broadcast <eventName>                                      Broadcast an event
    broadcastLocal <eventName>                                 Broadcast an event locally
    cache keys [options]                                       List keys of cache entries
    cache clear [pattern]                                      Clear cache entries
    call [options] <actionName> [jsonParams] [meta]            Call an action
    dcall [options] <nodeID> <actionName> [jsonParams] [meta]  Direct call an action
    clear [pattern]                                            Clear cache entries
    cls                                                        Clear console
    destroy <serviceName> [version]                            Destroy a local service
    emit <eventName>                                           Emit an event
    env                                                        List of environment variables
    events [options]                                           List of event listeners
    info                                                       Information about broker
    load <servicePath>                                         Load a service from file
    loadFolder <serviceFolder> [fileMask]                      Load all services from folder
    metrics [options]                                          List metrics
    nodes [options]                                            List of nodes
    services [options]                                         List of services

mol $



const { ServiceBroker } = require("moleculer");

//create Service Broker object 
const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        add: {
            async handler(ctx) {
                const { x, y } = ctx.params;
                return x + y; //Promise.resolve(x+y)
            }
        }
    }
})
async function main() {
    try {
        await broker.start();
        // const res = await broker.call('math.add',{x:10,y:20})
        // console.log(res);
        broker.repl();
    }
    catch(err){
        console.log(err);
    }
}
main();
..............................................................................................

Services:

-admin service
   services for monitoring moleculer application
$node

-application services
math,customer,user

 $ call $node.services
>> Call '$node.services' with params: {}
>> Execution time:467μs
>> Response:
[
  {
    name: '$node',
    version: undefined,
    fullName: '$node',
    settings: {},
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-19776' ]
  },
  {
    name: 'math',
    version: undefined,
    fullName: 'math',
    settings: {},
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-19776' ]
  }
]
mol $
..............................................................................................
				Methods Types

/////////////////////////////////////////////////////////////////////////////////////////////

Service Methods:

1.public methods
  methods are accssiable outside 
2.private methods
  methods are not accssible outside
  methods are used to isloate complex logic from public methods.

  //public methods
    actions: {
        add(ctx) {
            const { a, b } = ctx.params;
            const result = this.addNumbers(a, b);
            return result;
        },
        substract(ctx) {
            const { a, b } = ctx.params;
            const result = this.substractNumbers(a, b);
            return result;
        },
    }

  //private methods
    methods: {
        addNumbers(a, b) {
            return a + b;
        },
        substractNumbers(a, b) {
            return a - b;
        }
    }


const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker();

broker.createService({
    name: 'calculator',
    //public methods
    actions: {
        add(ctx) {
            const { a, b } = ctx.params;
            const result = this.addNumbers(a, b);
            return result;
        },
        substract(ctx) {
            const { a, b } = ctx.params;
            const result = this.substractNumbers(a, b);
            return result;
        },
    },
    //private methods
    methods: {
        addNumbers(a, b) {
            return a + b;
        },
        substractNumbers(a, b) {
            return a - b;
        }
    }
})


async function main() {
    try {
        await broker.start()
        const res = await broker.call('calculator.add', { a: 10, b: 10 })
        console.log(res);
        const res1 = await broker.call('calculator.substract', { a: 10, b: 2 })
        console.log(res1);

    }
    catch (err) {
        console.log(err);
    }

}
main();
.............................................................................................
				Service Communications























































