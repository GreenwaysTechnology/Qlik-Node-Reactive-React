					MicroServices
..............................................................................................

What is Micro Service?

MicroService is collection of architecture principles for building distributed applications.

Distributed Application:

Biz Models

-Data 
   -Store    - Data Layer
   -Process   - Service
   -Presentation -UI layer

History of Distributed Computing:

1.IBM MainFrame
    
 Thin client-------|IBM MainFrame---Process + DataStorage

2.Client-Server - Based Micro Computers
  
  Single Tier client server

 PersonalComputer-------|MicroComputer---Process + DataStorage

 Two Tier client server  -RPC 

 PersonalComputer-------|MicroComputer---Process + DataStorage
 (UI + BIZ Logic)-------MicroComputer-----DataStorage


 Three Tier client server  

  PersonalComputer-------|MicroComputer---Process + DataStorage

 (UI + client side biz logic)-------MicroComputer--server side biz logic---DataStorage

 N-Tier client server  

  PersonalComputer-------|MicroComputer---Process + DataStorage

 (UI + client side biz logic)---------[server side biz logic-m1]--network---[DataStorage-m2]

After 1990s

N-Tier client server - web based

  UI(Browser)------internet----http-------|WebServer----|WebContainers---Run a program--database.
...........................................................................................
			 N-Tier client server -Java - JEE
...........................................................................................

Technology Components of N-Tier client server Architecture in java:
.........................................................

1. Web container - JVM - Where we are running web compoents
     -Web Tech - Servlets/JSP
2. JDBC - connector to connect databases

How application was built and delivered to the customer?

-SDLC - Water fall

-Req
-Design
-development
-testing
-deployment-Production 
  ----Live
   
Monolith:

-Technology first J2EE, Domain Next.

Problems in Traditonal destributed app development:

-Vendor-lock in : Mono-lithic
   -DEV,TESTING,PRODUCTION.
-Work flow is highly sequencial
   Req -Complete
   Dev
   testing
   Release
   Production
  Delay in delivery:Cost increased
-Production cost was huge

Data Centers
 -need to purchase high powered servers - bare metal servers
 
Cost:
   -Hardware
   -OS -Linux-Ubuntu
   -Tools -Servers,databases etc....
   -Matrix Hell -  Mapping software components in dev and Production..
............................................................................................					Amzon and distributed Computing
............................................................................................

How to simplify the Software work flow?

Automation: Devops
  Testing
  Release
  Production

Different Tech Stack:
 -Break the Application into smaller and smaller application

Build ,test,release ,deploy , maintain in smaller -  sub domains

IF App needs to talk to external systems like Message Brokers, other Systems like Main frames.

RPC/RPI
MOM
Connectors Arch.

BIZ LOGIC:

1- Service Layer : isloate service layer into separate component

 can be inside one app - one layer, that layer may run on different jvms -  distributed Arch.


Layer :

 Client ---- Web Layer  ----Service Layer ---- Repository Layer
...............................................................................................
/////////////////////////////////////////////////////////////////////////////////////////////

Packaging Model:
 
WAR - Web archive
EAR .

Problems with Single JAR/WAR:

1. Scalability
 Vertical scablitity
 Horzitional scability 

2.Deployments
    -Bare Metal Deployment

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
Monoloith distributed app development drabackbacks:

-Time is taken for project delivery
   -Requirements 
   -High level design and low level design
   -coding
   -testing
   -release
   -production- live

-Technology Stack and Vendor lock in
   -You need to build the entire app using one technology or one vendor product
    eg: J2EE, Oracle,Weblogic

-Production and maintance cost
  -You need to setup large data centers , you need to maintain them.

Companies like amzon,netflix,google wanted to change the app development model.
                                "Micro services"


Micro services are architural model of req,dev,test,relase,production,maintaince different ways.
    Continous req collecting
    Continous dev
    Continuous testing
    Continuous release
    Continuous deployment
    Using rented data centers: Cloud

-Domain First, Technology Next: Domain Driven Design.
-No Vendor lock- Multi tech stack.
-Indidual dev , deployment - orders is development ,tested,deployed,customers are developed,tested deployment.
   -Parrel dev.
-Automation -dev ops
   release - CI 
   deployment - Containerized - Docker..
-Introduction of Cloud computing
...............................................................................................		..............................................................................................

                                  Micro Services Design Pattern
..............................................................................................

Implementation Patterns:
........................

1.DOMAIN Models
  Decompose by biz features
  Decompose by sub domains

..............................................................................................					Micros services Development - pattern
..............................................................................................

1.Select Language and Frameworks
   Javascript 

JavaScript Features
 -Services are exposed as "Objects"

Domain - OrderManagement

-OrderMaster
-OrderDetail

Objects
  -state
  -behvaiour - methods -biz operation
..............................................................................................						Service Design

Services are Objects.
....................

Services are exposed as Object in diffent style.How to access those objects outside and inside system.

Services are exposed as "APIS"

API Design Styles:

1.WebServices
   -SOAP Based -SOA
   -REST API
   -GRAPHQL API
2.RPC
.............................................................................................
				Service Communications
 
   Two Domains are going to collbrate each other to carry a biz transaction.


In Micro Services


FiberOpticService
     is 
   Running 
     inside
 One Application
       |
     Runtime
       |
  VM -Container

      OS
 
     |
     |   data
     |

Billing is Running
     is 
   Running 
     Another
 One Application
      |
     Runtime
       |
  VM -Container

      OS

Class ----will become  Objects

Object Communication === Service Communication



-SAME JVM(Runtime)
  Calling methods from one object(FiberDataService) to another object (BillingService).
-Different Runtime(JVM)
   -Networks - Protocals
    RestFull
      -HTTP 
   -RPC/RIP
	-ORB
        -RMI
        -gRpc
   -MOM - Message Brokers
        RabbitMQ
	Kaffka
	etc...
   -Event Bus
	-TCP

..............................................................................................					Service communication related Design Pattern
				   (Sevices Are Eagar or Lazy)
..............................................................................................

Types of Communication.

1.Async Communication 
    -MOM - RabbitMQ
    -Programm level async communication - threads,nonblocking ios
2.Sync Communication
.............................................................................................
			Service Failures - Realiability Pattern
.............................................................................................

1.UnAvailability

2.Timeout due to slow calls

How to handle failures , how to return proper response to caller?

Reliability Design patterns :fault tolerance 

 -Circuit Breaker
 -Bulk Head
 -Rate Limiter
 -Retry
 -TimeLit
.............................................................................................
				Service Communications in network and its Problems:
..............................................................................................

Service Communications in network and its Problems:
...................................................

Services are going to talk each other.

If they want to talk, What services should know each other?

 -Location
     ip address

In monolithic(traditional) deployment - ip address , ports are well known (hardcoded)
but in containers/ cloud env which are highly dynamic.

Where Micro services typically runs in a virtualized or containerized envs , locations are highly dynamic.

Services need to be registered some where and others services will ask registered location, that , hey give me that service

Service Registry and Discovery Pattern:
.......................................
Service Registry:
  -database - stores service informations

Service Discovery:
  locating services from the service registry

Types of Service discovery:
 -Client Side Service Discovery
 -Server Side Service Discovery
.............................................................................................
.............................................................................................
			DataSource - /Database Design in Micro services
..............................................................................................
Data Management :

 A Service need to store data in data sources - Database
  
Database Per Service.

 FiberOpticService
Each service has its own schema. 
you can have more than one tables per service

Database: 
  Collection of tables,views,other objects

Shared Database:
  Sharing db for more than one services .

Service Communication and Data Management

How to implement Transactions In Microservices?

It is very very difficult to implement and track transactions across multiple services.

Transactional Designpattern:

1.2PC  - 2 Phase Commit

2.Saga
    -EDA - Event Driven Architectures
  Saga Implementation
	-Choreography
        -Orchestration

..............................................................................................
				Deployment
..............................................................................................

Deployment patterns

Multiple service instances per host
Service instance per host
Service instance per VM
Service instance per Container
Serverless deployment
Service deployment platform
............................................................................................
			Management Patterns
...........................................................................................


2.Application Metrics
     To monitor Application behaviours

Tools:
   Prometheus
   AWS Cloud Watch

3.Auditing
    User auditing,application auditing - Performance
    Record User activties in a databse

4.Distributed Tracing /Tracking
   If i want to track service calls
    A -->B ---C -- Something
   You can Track Exception Hierachies
  
 Open zipkin
 Open Tracing

5.Health Check Api
    To test health of apis,infra components.

 Some implemetations provides health endpoints where you can get helath metrics information
that can be feed to tools 

-Prometheus
.............................................................................................
////////////////////////////////////////////////////////////////////////////////////////////
				Micro Services - Implementations
............................................................................................

Microservices is langugage,platform,os independant. 

Java:
 -Spring Cloud
 -Quarkus
 -Light4J
 -Vertx
 etc...

Javascript : nodejs

-  Moleculer
-  Seneca
-  Loop back
..............................................................................................

        Moleculer

Progressive microservices framework for Node.js

Moleculer is framework which has implemented most of common microservices design patterns.

Moleculer features:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
7.plugin/middleware system
8.support versioned services
9.support Streams
10.service mixins
11.built-in caching solution (Memory, MemoryLRU, Redis)
12.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
13.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
14.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
15.pluggable parameter validator
16.multiple services on a node/server
17.master-less architecture, all nodes are equal
18.parameter validation with fastest-validator
19.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
20.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
21.official API gateway, Database access and many other modules…
.............................................................................................
				Moleculer Architecture and Core concepts
.............................................................................................

1.Service:
  A Service is a simple java script module containing some part of a complex application.
  eg: UserService - contains information about users -  findAll users,save user,findBy,delete,update.
 It is isloated and self contained from the whole application, every service independant, meaning that even if the service goes offline or crashes the remaining services would be unaffected.

2.Node
   A node is simple os process(noderuntime). node may run local machine or external network.
   On a node one or more services are running.

3.Service Broker
   Service Broker is heart of moleculer.
   Service Broker is runtime for moleculer apps.
   Service Broker provides all infrastructure components - like    servicediscovery,loadbalancer,network transporters,message bus .... 

4.Transporter
   Transporter is communication bus that services are used to communicate across the network
   It can transfer message,events,request,response....

5.GateWay
    API Gateway exposes exposes moleculer services to end users.
   if external system/users who can communicate moleculer micro service apps via gate way only.
.............................................................................................
				Services:

1.HTTP services - REST API Style
   Services are exposed for outsideworld

2.Back end services - RPC API Style
   Services are used to encasulate biz logics like database operations,any biz


service names and file names:

math.service.js
hello.service.js

Create  Service Broker Object

const { ServiceBroker } = require('moleculer')

//ServiceBroker object creation
const broker = new ServiceBroker();

microserviceapp>node services/brokerinit.service.js
[2021-10-04T05:35:35.211Z] INFO  laptop-r2tggfdl-15380/BROKER: Moleculer v0.14.17 is starting...
[2021-10-04T05:35:35.213Z] INFO  laptop-r2tggfdl-15380/BROKER: Namespace: <not defined>
[2021-10-04T05:35:35.213Z] INFO  laptop-r2tggfdl-15380/BROKER: Node ID: laptop-r2tggfdl-15380
[2021-10-04T05:35:35.215Z] INFO  laptop-r2tggfdl-15380/REGISTRY: Strategy: RoundRobinStrategy
[2021-10-04T05:35:35.215Z] INFO  laptop-r2tggfdl-15380/REGISTRY: Discoverer: LocalDiscoverer
[2021-10-04T05:35:35.222Z] INFO  laptop-r2tggfdl-15380/BROKER: Serializer: JSONSerializer
[2021-10-04T05:35:35.233Z] INFO  laptop-r2tggfdl-15380/BROKER: Validator: FastestValidator
[2021-10-04T05:35:35.235Z] INFO  laptop-r2tggfdl-15380/BROKER: Registered 13 internal middleware(s).
[2021-10-04T05:35:35.250Z] INFO  laptop-r2tggfdl-15380/$NODE: Service '$node' stopped.
[2021-10-04T05:35:35.251Z] INFO  laptop-r2tggfdl-15380/BROKER: ServiceBroker is stopped. Good bye.
.........................................................................................
				Service Design - RPC

const { ServiceBroker } = require("moleculer");

//create Service Broker object 
const broker = new ServiceBroker();

//Create Service Object
//service schema - Object definition
broker.createService({
    name: 'hello',
    actions: {
        //apis
        sayHello() {
            return 'Hello,MicroService!!'
        }
    }
});

// function main() {
//     //start the broker and deploy the service
//     broker.start()
//         .then(() => {
//             console.log('services are ready to access')
//             //invoke service methods
//             broker.call('hello.sayHello')
//                 .then(res => console.log(res))
//                 .catch(err => console.log('service method gives error ', err));
//         })
//         .catch(err => {
//             console.log('deployment failed -->', err)
//         });
// }

//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        const response = await broker.call('hello.sayHello');
        console.log(response);
    }
    catch (err) {
        console.log(err);
    }

}


main();
.............................................................................................
				Single Service Multiple Methods
..............................................................................................
const { ServiceBroker } = require("moleculer");

//create Service Broker object 
const broker = new ServiceBroker();

//Create Service Object
//service schema - Object definition
broker.createService({
    name: 'greeter',
    actions: {
        //apis
        sayHello() {
            return 'Hello,MicroService!!'
        },
        sayHai() {
            return 'Hai,MicroService!!!';
        },
        sayWelcome() {
            return 'Welcome ,MicroService!'
        }
    }
});

//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        const hello = await broker.call('greeter.sayHello');
        const hai = await broker.call('greeter.sayHai')
        const greet = await broker.call('greeter.sayWelcome')
        console.log(hello);
        console.log(hai);
        console.log(greet);

    }
    catch (err) {
        console.log(err);
    }

}


main();
.............................................................................................
				  MultiService On single Broker
.............................................................................................

const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,MicroService!!'
        },
    }
});

broker.createService({
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai,MicroService!!'
        },
    }
});


broker.createService({
    name: 'welcome',
    actions: {
        sayWelcome() {
            return 'Welcome,MicroService!!'
        },
    }
});

//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        const hello = await broker.call('hello.sayHello');
        const hai = await broker.call('hai.sayHai')
        const greet = await broker.call('welcome.sayWelcome')
        console.log(hello);
        console.log(hai);
        console.log(greet);

    }
    catch (err) {
        console.log(err);
    }

}


main();
...............................................................................................					Versioning Services
http://mydomain/api/v1/someresource

http://mydomain/api/v2/someresource

const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    version: 1,
    actions: {
        sayHello() {
            return 'Hello,Legacy MicroService!!'
        },
    }
});


broker.createService({
    name: 'hello',
    version: 2,
    actions: {
        sayHello() {
            return 'Hello,Modern MicroService!!'
        },
    }
});

//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        const oldhello = await broker.call('v1.hello.sayHello');
        const newhello = await broker.call('v2.hello.sayHello');
        console.log(oldhello);
        console.log(newhello);

    }
    catch (err) {
        console.log(err);
    }

}

main();
..............................&&&&&&&&&&&&&&&&&&............................................
				Meta Data and actions -  actions types

actions:
  Are used to represent methods.

Methods can be represented in two ways:

Way -1:
actions : {
 
  sayHello(){
     return 'hello'
  }

}
Way-2: you can add meta information to a methods

meta informations will discuss later.

actions: {
  
  sayHello: {
    
       handler(){
          
          return 'Hello'
           
       } 
  }

} 

const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'greeter',
    version: 1,
    actions: {
        sayHello: {
            //handler:biz logic goes inside
            handler() {
                return 'Hello! Handler Microservice'
            }
        },
        sayHai: {
            handler() {
                return 'Hai! Handler Microservice!'
            }
        }
    }
});


async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        const hello = await broker.call('v1.greeter.sayHello');
        const hai = await broker.call('v1.greeter.sayHai');

        console.log(hello);

    }
    catch (err) {
        console.log(err);
    }

}

main();
*********************************************XXXXXXXXXX***************************************

Args and Parameters


Args: - Receiver:
................
const hello = await broker.call('hello.sayHello',{name:'Subramanian'})

-Parameters must be encapsulated inside object only - {name:'subramanian'}

-Args must be received via one Object called "Context" Object

Context :

-it is proxy object for broker meaning that, similar broker.
-Most of the broker features are availble inside context object
-Context objects are created by moleculer automatically.
-We can grab context object reference inside actions method args
-Using context 
   -read parameters - ctx.params
   -you can call other service methods -  service communication. ctx.call
   -if you want to access broker information 

const { ServiceBroker } = require("moleculer");

const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    actions: {
        sayHello(ctx) {
            // console.log(ctx.params.name);
            const { name,message } = ctx.params;
            return `${message} , ${name}`
        }
    }
});



//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        //pass parameters
        const response = await broker.call('hello.sayHello', { name: 'Subramanian',message:'Hello' });
        console.log(response);
    }
    catch (err) {
        console.log(err);
    }

}


main();
..........................................................................................
				 Params Validation
...........................................................................................

const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {

        add: {
            //metadata : Validatation code
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params;
                return a + b;
            }
        }
    }
});



//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        //pass parameters
        let response;
        response = await broker.call('math.add', { a: 10, b: 10 });
        console.log(response);
        response = await broker.call('math.add', { a: 10, b: 10 });
        console.log(response);
        response = await broker.call('math.add', { a: '10', b: 10 });
        console.log(response);
    }
    catch (err) {
        console.log(err);
    }

}


main();
.............................................................................................
				Async code - with Timer and Promise
.............................................................................................
const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {

        add: {
            //metadata : Validatation code
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params;
                //wrap the code inside timer and promise
                return new this.Promise((resolve, reject) => {
                    setTimeout(resolve, 5000, (a + b))
                })
            }
        }
    }
});



//async await
async function main() {
    //start the broker and deploy the service
    try {
        await broker.start()
        //pass parameters
        let response;
        response = await broker.call('math.add', { a: 10, b: 10 });
        console.log(response);

    }
    catch (err) {
        console.log(err);
    }

}


main();
.............................................................................................
				Service Parameters Dynamically
...........................................................................................


REPL: READ Evaulate Print Loop:
- interactive command line tool, used for testing application.

node provides REPL
node

Moleculer provides REPL Prompt for testing services interactivly.

npm install moleculer-repl --save-dev

>node services/repl.service.js
[2021-07-24T09:34:52.394Z] INFO  laptop-r2tggfdl-6988/BROKER: Moleculer v0.14.16 is starting...
[2021-07-24T09:34:52.396Z] INFO  laptop-r2tggfdl-6988/BROKER: Namespace: <not defined>
[2021-07-24T09:34:52.397Z] INFO  laptop-r2tggfdl-6988/BROKER: Node ID: laptop-r2tggfdl-6988
[2021-07-24T09:34:52.398Z] INFO  laptop-r2tggfdl-6988/REGISTRY: Strategy: RoundRobinStrategy
[2021-07-24T09:34:52.399Z] INFO  laptop-r2tggfdl-6988/REGISTRY: Discoverer: LocalDiscoverer
[2021-07-24T09:34:52.407Z] INFO  laptop-r2tggfdl-6988/BROKER: Serializer: JSONSerializer
[2021-07-24T09:34:52.419Z] INFO  laptop-r2tggfdl-6988/BROKER: Validator: FastestValidator
[2021-07-24T09:34:52.421Z] INFO  laptop-r2tggfdl-6988/BROKER: Registered 13 internal middleware(s).
[2021-07-24T09:34:52.440Z] INFO  laptop-r2tggfdl-6988/REGISTRY: '$node' service is registered.
[2021-07-24T09:34:52.443Z] INFO  laptop-r2tggfdl-6988/REGISTRY: 'math' service is registered.
[2021-07-24T09:34:52.443Z] INFO  laptop-r2tggfdl-6988/$NODE: Service '$node' started.
[2021-07-24T09:34:52.444Z] INFO  laptop-r2tggfdl-6988/MATH: Service 'math' started.
[2021-07-24T09:34:52.445Z] INFO  laptop-r2tggfdl-6988/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 13ms.
mol $ help

  Commands:

    help [command...]                                          Provides help for a given command.
    q                                                          Exit application
    actions [options]                                          List of actions
    bench [options] <action> [jsonParams] [meta]               Benchmark a service
    broadcast <eventName>                                      Broadcast an event
    broadcastLocal <eventName>                                 Broadcast an event locally
    cache keys [options]                                       List keys of cache entries
    cache clear [pattern]                                      Clear cache entries
    call [options] <actionName> [jsonParams] [meta]            Call an action
    dcall [options] <nodeID> <actionName> [jsonParams] [meta]  Direct call an action
    clear [pattern]                                            Clear cache entries
    cls                                                        Clear console
    destroy <serviceName> [version]                            Destroy a local service
    emit <eventName>                                           Emit an event
    env                                                        List of environment variables
    events [options]                                           List of event listeners
    info                                                       Information about broker
    load <servicePath>                                         Load a service from file
    loadFolder <serviceFolder> [fileMask]                      Load all services from folder
    metrics [options]                                          List metrics
    nodes [options]                                            List of nodes
    services [options]                                         List of services

mol $



const { ServiceBroker } = require("moleculer");

//create Service Broker object 
const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        add: {
            async handler(ctx) {
                const { x, y } = ctx.params;
                return x + y; //Promise.resolve(x+y)
            }
        }
    }
})
async function main() {
    try {
        await broker.start();
        // const res = await broker.call('math.add',{x:10,y:20})
        // console.log(res);
        broker.repl();
    }
    catch(err){
        console.log(err);
    }
}
main();
..............................................................................................

Services:

-admin service
   services for monitoring moleculer application
$node

-application services
math,customer,user

 $ call $node.services
>> Call '$node.services' with params: {}
>> Execution time:467μs
>> Response:
[
  {
    name: '$node',
    version: undefined,
    fullName: '$node',
    settings: {},
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-19776' ]
  },
  {
    name: 'math',
    version: undefined,
    fullName: 'math',
    settings: {},
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-19776' ]
  }
]
mol $
..............................................................................................
				Methods Types

/////////////////////////////////////////////////////////////////////////////////////////////

Service Methods:

1.public methods
  methods are accssiable outside 
2.private methods
  methods are not accssible outside
  methods are used to isloate complex logic from public methods.

  //public methods
    actions: {
        add(ctx) {
            const { a, b } = ctx.params;
            const result = this.addNumbers(a, b);
            return result;
        },
        substract(ctx) {
            const { a, b } = ctx.params;
            const result = this.substractNumbers(a, b);
            return result;
        },
    }

  //private methods
    methods: {
        addNumbers(a, b) {
            return a + b;
        },
        substractNumbers(a, b) {
            return a - b;
        }
    }


const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker();

broker.createService({
    name: 'calculator',
    //public methods
    actions: {
        add(ctx) {
            const { a, b } = ctx.params;
            const result = this.addNumbers(a, b);
            return result;
        },
        substract(ctx) {
            const { a, b } = ctx.params;
            const result = this.substractNumbers(a, b);
            return result;
        },
    },
    //private methods
    methods: {
        addNumbers(a, b) {
            return a + b;
        },
        substractNumbers(a, b) {
            return a - b;
        }
    }
})


async function main() {
    try {
        await broker.start()
        const res = await broker.call('calculator.add', { a: 10, b: 10 })
        console.log(res);
        const res1 = await broker.call('calculator.substract', { a: 10, b: 2 })
        console.log(res1);

    }
    catch (err) {
        console.log(err);
    }

}
main();
.............................................................................................
				Service Communications


Types of services:

1.local service
   service which is implemented on single broker.
2.remote service
   Service which is implemented across the brokers.
 
Services can communicate within service broker-single node.


Localservices:
const { ServiceBroker } =  require("moleculer");

const broker = new ServiceBroker();

//calculator service
broker.createService({
    name: 'calculator',
    actions: {
        add(ctx) {
            const { a, b } = ctx.params;
            //call another service : service communications
            return ctx.call('adder.add',{a:a,b:b});
        }
    }
})
broker.createService({
    name: 'adder',
    actions: {
        add(ctx) {
            const { a, b } = ctx.params;
            return a + b;
        }
    }
})


async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();
..............................................................................................
.............................................................................................
				Remote Services and Communication:
	
					Remote Services
				     (Distributed Services)
.............................................................................................

Remote Services
-Services are located across the nodes.
-nodes can be the same machine or different machines, or cloud.

Steps:

Run three services in a different node.

node services/remote1.service.js

node services/remote2.service.js

node services/remotemain.service.js

2.Open three command prompt and run the services

$>node services/remotemain.service.js
$>node services/remote1.service.js
$>node services/remote2.service.js

 Call 'main.begin' with params: { a: 10, b: 20 }
[2021-10-05T04:40:35.357Z] WARN  laptop-r2tggfdl-2952/BROKER: Service 'calculator.add' is not registered.
>> ERROR:
ServiceNotFoundError: Service 'calculator.add' is not found.
    at ServiceBroker.findNextActionEndpoint (E:\session\Qlik\microservicesapp\node_modules\moleculer\src\service-broker.js:1087:13)
    at ServiceBroker.call (E:\session\Qlik\microservicesapp\node_modules\moleculer\src\service-broker.js:1136:26)
    at Context.call (E:\session\Qlik\microservicesapp\node_modules\moleculer\src\context.js:286:23)
    at Service.handler (E:\session\Qlik\microservicesapp\services\remotemain.service.js:12:28)
    at E:\session\Qlik\microservicesapp\node_modules\moleculer\src\utils.js:212:22
    at ServiceBroker.timeoutMiddleware (E:\session\Qlik\microservicesapp\node_modules\moleculer\src\middlewares\timeout.js:31:14)
    at ServiceBroker.fallbackMiddleware (E:\session\Qlik\microservicesapp\node_modules\moleculer\src\middlewares\fallback.js:31:11)
    at ServiceBroker.errorHandlerMiddleware (E:\session\Qlik\microservicesapp\node_modules\moleculer\src\middlewares\error-handler.js:14:10)
    at ServiceBroker.call (E:\session\Qlik\microservicesapp\node_modules\moleculer\src\service-broker.js:1160:31)
    at call (E:\session\Qlik\microservicesapp\node_modules\moleculer-repl\src\commands\call.js:90:9)
Data:


Why the above error?

-Service not able to locate the other service, since other services are running in different 
nodes
............................................................................................

.............................................................................................
					 Networking
.............................................................................................

In order to enable Remote Service communications , we need Transporters

Transporter is a channel and bridge layer among services.


In order to enable Remote Service communications , we need Message Brokers 


Transporters:

-Transporter is an important module if you are running services on multiple nodes. 

-Transporter communicates with other nodes. 

-It transfers events, calls requests and processes responses …etc. 

-If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.


Transports:
............

Built-in transporters

TCP transporter
NATS Transporter
Redis Transporter
MQTT Transporter
AMQP Transporter
Kafka Transporter
NATS Streaming (STAN) Transporter


NATS Transporter:

1.you have to run Transporter broker software

 like redis server or nats server ,AMQP server.....

NATS: Bridge :https://nats.io/download/

docker run  --name nats-main -d -p 4222:4222 -p 6222:6222 -p 8222:8222 nats 


if you want to change transporter from nats to others(TCP/Redis/kafka)...

transporter: 'TCP',


Steps:

1.main Server
const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker({
    // transporter: "nats://localhost:4222",
    transporter: 'TCP',
    nodeID: 'Qlik-MainServer'

});

broker.createService({
    name: 'main',
    actions: {
        begin: {
            handler(ctx) {
                const { a, b } = ctx.params;
                //call service1 remote1.service.js
                return ctx.call('calculator.add', { a: a, b: b });

            }
        }
    }
})


async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

services/remote1.service.js
const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker({
    // transporter: "nats://localhost:4222",
    transporter: 'TCP',

    nodeID : 'Qlik-Server1'

});

broker.createService({
    name: 'calculator',
    actions: {
        add: {
            handler(ctx) {
                const { a, b } = ctx.params;
                //call service1 remote1.service.js
                return ctx.call('adder.add', { a: a, b: b });

            }
        }
    }
})


async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();
////

services/remote2.service.js
const { ServiceBroker } = require("moleculer");

const broker = new ServiceBroker({
    // transporter: "nats://localhost:4222",
    transporter: 'TCP',
    nodeID : 'Qlik-Server2'
});

broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                const { a, b } = ctx.params;
                //call service1 remote1.service.js
                return `${a + b} from ${broker.nodeID}`

            }
        }
    }
})


async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();
............................................................................................
				 Service Inheritance
...........................................................................................

Objective:
  -code sharing, common code inside a service, which can be shared/inherited into other services.

Service inheritance comes into place.

In molecular , a service can inherit many services - multi level, for multi level, molcular uses a concept called "mixins".

mixins is a design pattern used in javascript to implement multi level inheritance like java uses interfaces.


Use case:
1.if you write any REST Controller.
2.if you write database operations inside your service.


How to write services in a different file

How to do inheritance(service mixins) - mixin means multilevel 



services/child.service.js

const Parent = require('./parent.service');
const ParentTwo = require('./parent2.service');

const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker();


broker.createService({
    name: 'greeter',
    mixins: [Parent,ParentTwo], // inheritance
    actions: {
        sayGreet() {
            return 'Greeter From Child';
        }
    }
})


async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

services/parent2.service.js

//plain service object 
module.exports = {
    name: 'hai',
    actions: {
        sayHai() {
            return 'hai,From Parent';
        }
    }

};


services/parent2.service.js

//plain service object 
module.exports = {
    name: 'hai',
    actions: {
        sayHai() {
            return 'hai,From Parent';
        }
    }

};
...............................................................................................				GateWay - HTTP API Services
..............................................................................................

How to build http api in moleculer?

-RESTFull Services
-GraphQL Services


moleculer-web Module 

Features:
support HTTP & HTTPS
serve static files
multiple routes
support global, route, alias middlewares
support file uploading
alias names (with named parameters & REST shorthand)
whitelist
multiple body parsers (json, urlencoded)
CORS headers
ETags
HTTP2
Rate limiter
before & after call hooks
Buffer & Stream handling
middleware mode (use as a middleware in ExpressJS Application)
support authorization

How to begin?

npm install moleculer-web --save


services/first.service.js
const { ServiceBroker } = require('moleculer');
const ApiGateWay = require('moleculer-web');

const broker = new ServiceBroker();

//REST Service

broker.createService({
    name: 'greeterREST',
    actions: {
        sayHello() {
            return 'Hello,REST service'
        }
    }
})
//REST Server:
broker.createService(ApiGateWay);

async function main() {
    await broker.start();
}
main();
..............................................................................................
				How to call Back end Services from REST
.............................................................................................

/back end services

//http://localhost:3000/servicename/methodname
//http://localhost:3000/greeter/sayHello
http://localhost:3000/hello/sayHello


const { ServiceBroker } = require('moleculer');
const ApiGateWay = require('moleculer-web');

const broker = new ServiceBroker();

//REST Service

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Greeter,REST service'
        }
    }
})

broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,REST service'
        }
    }
})
//REST Server:
broker.createService(ApiGateWay);

async function main() {
    await broker.start();
}
main();
..............................................................................................
const { ServiceBroker } = require('moleculer');
const ApiGateWay = require('moleculer-web');
const USERS = require('./mock-data/users');

const broker = new ServiceBroker();


broker.createService({
    name: 'users',
    actions: {
        list: {
            handler(ctx) {
                return new this.Promise((resolve, reject) => {
                    setTimeout(resolve, 5000, JSON.stringify(USERS));
                });
            }
        }
    }
})

broker.createService(ApiGateWay);

async function main() {
    await broker.start();
}
main();
..............................................................................................
				  REST Server Setup - Routes
const { ServiceBroker } = require('moleculer');
const ApiGateWay = require('moleculer-web');

const broker = new ServiceBroker();

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello!';
        }
    }
})

broker.createService({
    name: 'admin',
    actions: {
        getAdmin() {
            return 'Admin!';
        }
    }
})

//http://localhost:3000/api/greeter/sayHello

//rest server with configuration
broker.createService({
    name: 'ApiGateServer',
    mixins: [ApiGateWay],
    //overriding the default Server settings
    settings: {
        routes: [{
            path: '/api'
        }, {
            path: '/admin'
        }]
    }
})


async function main() {
    await broker.start();
}
main();
.............................................................................................
    		How to restrict service method/actions access outside
............................................................................................
const { ServiceBroker } = require('moleculer');
const ApiGateWay = require('moleculer-web');

const broker = new ServiceBroker();

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello!';
        },
        sayHai() {
            return 'Hai!';
        },
        sayGreet() {
            return 'Greeter!';
        }
    }
})

broker.createService({
    name: 'admin',
    actions: {
        getAdmin() {
            return 'Admin!';
        }
    }
})

//http://localhost:3000/api/greeter/sayHello

//rest server with configuration
broker.createService({
    name: 'ApiGateServer',
    mixins: [ApiGateWay],
    //overriding the default Server settings
    settings: {
        routes: [{
            path: '/api',
            whitelist: [
               //Restrict to access only sayHello action
               "greeter.sayHello",
               //Restrict to access all actions in Greeter service
               //"greeter.*"
            ]

        },
        {
            path: '/admin'
        }]
    }
})


async function main() {
    await broker.start();
}
main();
/////////////////////////////////////////////////////////////////////////////////////////////
URL Mapping in moleculer:

http://localhost:3000/api/serviceName/actionName

  This is not good way to map urls , which more difficult to remember, it is not user friendly
it is not even secure,the reason, we expose the back end service to end users.

Aliases:
........
  You can use aliases(dummyname/fakename)-Virtual path, instead of action name.

 settings: {
        routes: [
            {
                path: "/api",
                aliases: { 

                    "hello" : "greeter.hello",
                    "users" :  "users.list"
                }             
            }
        ]

http://localhost:3000/api/hello
http://localhost:3000/api/users

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const USERS = require('./mock-data/users')

const broker = new ServiceBroker();

//back end service
broker.createService({
    name: "greeter",
    actions: {
        sayHello() {
            return "Hello"
        },
        sayWelcome() {
            return 'Welcome'
        },
        sayHai() {
            return 'Hai'
        }

    }
})

broker.createService({
    name: "users",
    actions: {
        list() {
            return USERS
        }
    }
})

//http://localhost:3000/api/hello
//http://localhost:3000/api/hai
//http://localhost:3000/api/welcome
//http://localhost:3000/api/list


broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                "hello": "greeter.sayHello",
                "hai": "greeter.sayHai",
                "welcome": "greeter.sayWelcome",
                "list": "users.list"
            }
        }]
    }
})


async function main() {
    await broker.start();
}
main();
















































