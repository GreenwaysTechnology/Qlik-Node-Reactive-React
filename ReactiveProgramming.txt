					Reactive Programming
..............................................................................................

What is Reactive Programming?

 It is one of the  Programming Paradigm(way) - oo,funcitonal,procedural.

Core Concepts:
1.Event Driven Programming - Object Communication.
                                     Reactive Programming 
//////////////////////////////////////////////////////////////////////////////////////////////

What is reactive programming?

It is one of the  Programming Paradigm(way).

Reactive programming is collection of many programming paradigm best parts and principles.

Reactive programming is collection of oo , functional, event driven......principles


Reactive Programming languages:
..............................

There is no such separate pl which adopts reactive programming alone.
 rather which is eXtended by other languages : 
Reactive programming is just like plugin, which has been pluged in inside languages via libs and frameworks.

Reactive-X(x means Extension /plugin)

C# can extend Reactive programming principles -Rx.net
Java even  - Rxjava
js  - rxjs
///////////////////////////////////////////////////////////////////////////////////////////

History of Rx Programming:
.........................

At Microsoft Erik Meijer who created Reactive Programming ideas from "C#".

Core Ideas behind Reactive Programming :

Object:
  -setters - write
  -getters - read

getters
   -single value - scallar values -number,strings,booleans,object
   -iteralble value(many values) - array , collection-list,map,set

Iterations:
 IEnumerable ,IEnumerator 

IEnumerator 
   - bridge interface which is used to iterate collection

  producer                                 consumer/subscriber Caller(requester)
  moveNext():boolean --------------------  give me a value /error

Based this we define programming model called "Pull based"

 consumer pulls value from producer.
 consumer has control over producer.
 consumer only decide when he wants item.

             "Values are produced on demand by consumer"

Before a decade, programming model started like "Cloud based, async programming Programming"
.............................................................................................
				Rxjs - Reactive Extension for Javascript
.............................................................................................

rxjs project setup: es 6
........................

Publisher,Subscriber,Operators

In Reactive Programming  , publisher is reprsented as object.

"Publisher Object Type":

core Type:

Observable: represents the idea of an invokable collection of future values or events.


Satellite Types:
................

Observer: is a collection of callbacks that knows how to listen to values delivered by the Observable.

Subscription: represents the execution of an Observable, is primarily useful for cancelling the execution.

Operators: are pure functions that enable a functional programming style of dealing with collections with operations like map, filter, concat, reduce, etc.

Subject: is the equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.

Schedulers: are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. setTimeout or requestAnimationFrame or others.



Observables:

-It is lazy push collections of multiple..


There are many ways to create Observable object, then push sequence of data.

1.using new Observable()
2.using operators

How to stream data?


import { Observable, Subscriber } from "rxjs";

class Producer {
    constructor() {

    }
    //push/stream sequence of values
    startStream() {
        //create Publisher
        return new Observable(subscriber => {
            //start push values:trigger data event
            console.log('ob')
            subscriber.next(1);
            subscriber.next(2);
            subscriber.next(3);
            try {
                let myNumber = 100;
                if (myNumber === 100) {
                    throw Error('something went wrong')
                }
            }
            catch (err) {
                subscriber.error(err);
            }
            subscriber.next(4);
            subscriber.next(5);
            setTimeout(() => {
                subscriber.next(6);
                //  subscriber.complete();
            }, 5000)
            // let timerId = setInterval(() => {
            //     subscriber.next(Math.random())
            // }, 1000);
            //subscriber.complete();
            // setTimeout(() => {
            //     clearInterval(timerId)
            //     //stop sending data , which tells close the outbound channel
            //     // subscriber.complete();
            // }, 10000)
        });

    }
}

class Consumer {
    constructor(producer) {
        this.producer = producer;
    }
    consumeStream() {
        //bind listenter
        const subscription = this.producer.startStream()
            .subscribe(data => console.log(data),
                err => console.log(err),
                () => console.log('stream Completed!'));
        //unsubscribe : stop receiving data from the stream
        setTimeout(() => {
            console.log('Consumer left ):')
            subscription.unsubscribe();
        }, 10000)

    }
}
let producer = new Producer();
let consumer = new Consumer(producer);
consumer.consumeStream();
............................................................................................
				of - Streams sequence of  values
...........................................................................................
import { Observable, of, Subscriber } from "rxjs";

class Producer {
    constructor() {

    }
    startStream() {
        return of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    }
}

class Consumer {
    constructor(producer) {
        this.producer = producer;
    }
    consumeStream() {
        //bind listenter
        const subscription = this.producer.startStream()
            .subscribe(data => console.log(data),
                err => console.log(err),
                () => console.log('stream Completed!'));


    }
}
let producer = new Producer();
let consumer = new Consumer(producer);
consumer.consumeStream();
..............................................................................................
				Datasource
..............................................................................................
The data from where streamed.

Datasources:
 scallar values - numbers,strings,....
 collection values - array
 dom events
 Promise





